import { Callout, Tabs, Tab } from "nextra/components"

<Callout type="warning" emoji="⚠️">
  Work in progress.
</Callout>

# The From/To Pattern in Software Design

In the realm of software development, the From/To pattern is a crucial design principle that facilitates the transformation of objects into different forms, such as converting objects to strings, JSON, and other types. This pattern is vital in building adaptive and modular systems, promoting a seamless conversion between different object representations or states.

## Context

While building software, especially with layered architectures, implementing conversions in the higher layers, like REST inputs into Commands, or Postgres query Results into Entities, is fundamental. If multiple objects need conversion into one, an aggregate object implementing the To pattern should be created first.

## Opinion

Leveraging the From/To pattern is akin to preferring Dependency Injection over explicit import, promoting decoupling and enhancing code maintainability, testability, and readability. It allows the software to be more adaptable to change, and its components more interchangeable, giving developers the ability to switch implementations with minimal hassle.

## How to Implement

### Rust Example

<Tabs items={['Rust', 'Typescript']}>
<Tab>
```rust
trait ToJSON {
    fn to_json(&self) -> String;
}

struct Command {
value: String,
}

impl ToJSON for Command {
fn to_json(&self) -> String {
format!("{{\"value\": \"{}\"}}", self.value)
}
}

struct Aggregate {
commands: Vec<Command>,
}

impl ToJSON for Aggregate {
fn to_json(&self) -> String {
let json_commands: Vec<String> = self.commands.iter().map(|cmd| cmd.to_json()).collect();
format!("[{}]", json_commands.join(","))
}
}

fn main() {
let command = Command { value: "Create".to_string() };
let aggregate = Aggregate { commands: vec![command] };
println!("{}", aggregate.to_json()); // Outputs: [{"value": "Create"}]
}

````
</Tab>

### Typescript Example
<Tab>
```ts
interface ToJSON {
    toJSON(): string;
}

class Command implements ToJSON {
    constructor(private value: string) {}

    toJSON(): string {
        return `{"value": "${this.value}"}`;
    }
}

class Aggregate implements ToJSON {
    constructor(private commands: Command[]) {}

    toJSON(): string {
        return `[${this.commands.map(cmd => cmd.toJSON()).join(",")}]`;
    }
}

const command = new Command("Create");
const aggregate = new Aggregate([command]);
console.log(aggregate.toJSON()); // Outputs: [{"value": "Create"}]
````

</Tab>
</Tabs>

## Conclusion

The From/To pattern, like Dependency Injection, plays a pivotal role in creating maintainable and loosely coupled software architectures. It allows for the creation of more modular, readable, and testable code, making it easier for developers to understand and modify the software. By implementing it judiciously, developers can ensure smoother and more efficient development processes, leading to robust and adaptable software solutions.
