import { Callout, Tabs, Tab } from "nextra/components"

<Callout type="warning" emoji="⚠️">
  Work in progress.
</Callout>

# Newtype Pattern: Crafting Robust and Semantic Types

In programming, a common dilemma is managing primitive data types and ensuring that they conform to certain constraints. The Newtype pattern emerges as a solution, allowing developers to wrap primitive types in a way that conveys more meaning and enforces tighter constraints. For instance, instead of managing generic number types, we can create types like `PositiveInteger` and `NonZeroNumber`, making our programs more robust and semantically rich.

## Context

The Newtype pattern involves creating a new type that wraps around an existing type. It doesn’t alter the representation of the enclosed type but adds a new layer of meaning and constraints to it. This helps in avoiding logical errors related to the misuse of types, such as passing a negative number where a positive number is expected.

## Opinion

Embracing the Newtype pattern is essential for writing clear and error-resistant code. It improves the expressiveness of the type system, allowing developers to encode more domain-specific knowledge into the types, reducing the chances of errors and making the software more maintainable and self-documenting.

## How to Implement

### Rust Example

<Tabs items={['Rust', 'Typescript']}>
<Tab>
```rust
#[derive(Debug, PartialEq)]
struct PositiveInteger(u64);

impl PositiveInteger {
fn new(value: u64) -> Result<PositiveInteger, &'static str> {
if value > 0 {
Ok(PositiveInteger(value))
} else {
Err("Value must be a positive integer")
}
}
}

#[derive(Debug, PartialEq)]
struct NonZeroNumber(i64);

impl NonZeroNumber {
fn new(value: i64) -> Result<NonZeroNumber, &'static str> {
if value != 0 {
Ok(NonZeroNumber(value))
} else {
Err("Value must be a non-zero number")
}
}
}

fn main() {
let positive_integer = PositiveInteger::new(10).unwrap();
let non_zero_number = NonZeroNumber::new(-5).unwrap();

    println!("{:?}", positive_integer); // Outputs: PositiveInteger(10)
    println!("{:?}", non_zero_number); // Outputs: NonZeroNumber(-5)

}

````
</Tab>

### Typescript Example
<Tab>
```ts
class PositiveInteger {
    constructor(private value: number) {
        if (value <= 0) {
            throw new Error("Value must be a positive integer");
        }
    }

    getValue() {
        return this.value;
    }
}

class NonZeroNumber {
    constructor(private value: number) {
        if (value === 0) {
            throw new Error("Value must be a non-zero number");
        }
    }

    getValue() {
        return this.value;
    }
}

const positiveInteger = new PositiveInteger(10);
console.log(positiveInteger.getValue()); // Outputs: 10

const nonZeroNumber = new NonZeroNumber(-5);
console.log(nonZeroNumber.getValue()); // Outputs: -5
````

</Tab>
</Tabs>

## Conclusion

The Newtype pattern offers an expressive and resilient approach to managing primitive types, allowing developers to imbue types with more meaning and create self-documenting, robust software. By wrapping primitive types with more semantically rich and constrained types, developers can prevent a host of errors and make the software more aligned with domain-specific rules and logic. Employing such thoughtful approaches to type definition leads to software that is more understandable, maintainable, and less prone to bugs, fostering a sustainable and efficient development ecosystem.
