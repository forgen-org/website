# Why Microservices Architecture

**Date: 2023-12-17**

## The Need for Microservices

Consider the development of a versatile chatbot application. Our chatbot is designed with a simple yet effective interface:

```rs
pub trait ChatBot {
    fn receive_message() -> Stream<MessageReceived>;
    fn send_message(event: &MessageSent) -> ();
}
```

This design, inspired by hexagonal architecture, efficiently separates input handling (`receive_message`) from output (`send_message`). Our goal is flexibility, catering to various platforms like Discord bots, command-line interfaces, or web applications.

Take the Discord bot as an example. It necessitates its own HTTP server for event listening, a requirement specific to its operation. To maintain our design's flexibility, we embed this HTTP server logic within the DiscordService itself, rather than the application layer.

As we expand to multiple platforms, each with its unique configurations and requirements, managing them becomes complex. This is where microservices architecture shines. It allows us to deploy each service independently, with a centralized gateway efficiently handling different ports and routes.

**In conclusion, adopting a microservices-like architecture is not just a choice - it's a necessity for the seamless deployment and management of our diverse, multi-platform chatbot application.**

## Streamlined Communication

Our architecture involves diverse services like DiscordService and CLI interfaces, each needing a robust communication system. Direct HTTP or gRPC connections are impractical, exposing services to unnecessary internet risks and complexity. Here, message brokers like RabbitMQ or Kafka come into play, acting as intermediaries in our microservices structure.

```rs
trait MessageBroker<Event, Message> {
    fn receive_event() -> Stream<Event>;
    fn send_message(message: Message) -> ();
}
```

These microservices, acting as the proactive "clients" in our architecture, initiate interactions and handle inputs, whether from APIs, UIs, or CLIs. They also engage with and respond to events from the application layer. We'll streamline this by labeling these proactive elements as 'clients' and the responsive elements as 'services'.

A pivotal aspect is the unified persistence store, ensuring consistency across all clients. Utilizing a database like Postgres or MongoDB, or even a key-value store like Redis, allows for a centralized truth source, preventing data discrepancies.

**Ultimately, our microservices architecture, bolstered by a reliable message broker and a unified persistence strategy, sets the foundation for a cohesive, scalable chatbot ecosystem.**
